in jdk 1.8, ConcurrentHashMap not use Segment lock to maintain its thread safety.
instead, it use sync and CAS in its putVal method, below is the source code(line 22 for put, line 42 for delete)

/** Implementation for put and putIfAbsent */
final V putVal(K key, V value, boolean onlyIfAbsent) {
    if (key == null || value == null) throw new NullPointerException();
    int hash = spread(key.hashCode());
    int binCount = 0;
    for (Node<K,V>[] tab = table;;) {
        Node<K,V> f; int n, i, fh;
        if (tab == null || (n = tab.length) == 0)
            tab = initTable();
        else if ((f = tabAt(tab, i = (n - 1) & hash)) == null) {
            if (casTabAt(tab, i, null,
                         new Node<K,V>(hash, key, value, null)))
                break;                   // no lock when adding to empty bin
        }
        else if ((fh = f.hash) == MOVED)
            tab = helpTransfer(tab, f);
        else {
            V oldVal = null;
            synchronized (f) {
            ......
            
    /**
     * Implementation for the four public remove/replace methods:
     * Replaces node value with v, conditional upon match of cv if
     * non-null.  If resulting value is null, delete.
     */
    final V replaceNode(Object key, V value, Object cv) {
        int hash = spread(key.hashCode());
        for (Node<K,V>[] tab = table;;) {
            Node<K,V> f; int n, i, fh;
            if (tab == null || (n = tab.length) == 0 ||
                (f = tabAt(tab, i = (n - 1) & hash)) == null)
                break;
            else if ((fh = f.hash) == MOVED)
                tab = helpTransfer(tab, f);
            else {
                V oldVal = null;
                boolean validated = false;
                synchronized (f) {
                
before 1.8, it use Segment lock to main the thread safety.

before ConcurrentHashMap, there are several thread safety collections comparing with non thread safety colletion
1: CopyOnWriteArrayList -> ArrayList, use ReentrantLock
2: CopyOnWriteArraySet -> HashSet, ReentrantLock lock = this.lock;
3: ConcurrentSkipListMap
4: ConcurrentSkipListSet
5: ArrayBlockingQueue
6: LinkedBlockingQueue
7: LinkedBlockingDeque
8: ConcurrentLinkedQueue